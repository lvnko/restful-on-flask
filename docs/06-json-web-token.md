[回到目錄](overview.md) | [上一章](05-sessions-pros-n-cons.md) | [下一章](07-cross-origin.md)

## 6. JSON Web Token (JWT)

### 什麼是 JWT (JSON Web Token)？

JWT (JSON Web Token) 是一種開放標準 (RFC 7519)，它定義了一種簡潔且獨立的方式，用於在各方之間安全地傳輸資訊，這些資訊以 JSON 物件的形式存在。由於這些資訊是經過數位簽章的，因此可以被驗證和信任。

JWT 的核心優勢在於其**無狀態 (Stateless)** 的特性。伺服器不需要在後端儲存任何關於使用者的 Session 資訊。當客戶端發送請求時，只需附上 JWT，伺服器就能驗證其合法性並解析出使用者資訊。

一個 JWT Token 由三個部分組成，並以點 (`.`) 分隔：

`eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c`

這三個部分分別是：
1.  **標頭 (Header)**
2.  **負載 (Payload)**
3.  **簽章 (Signature)**

---

#### 1. 標頭 (Header)

標頭通常由兩個部分組成：
*   **`typ` (Type):** 令牌的類型，固定為 `JWT`。
*   **`alg` (Algorithm):** 用於產生簽章的加密演算法，例如 `HS256` (HMAC-SHA256) 或 `RS256` (RSA-SHA256)。

這個 JSON 物件會經過 **Base64Url** 編碼，形成 JWT 的第一部分。

**範例：**
```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```
**編碼後：** `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9`

---

#### 2. 負載 (Payload)

負載部分包含了**聲明 (Claims)**，這些是關於實體（通常是使用者）和其他附加資料的陳述。聲明分為三種類型：

*   **註冊聲明 (Registered Claims):** 這些是一組預先定義的聲明，雖然不是強制性的，但建議使用以確保互通性。常見的包括：
    *   `iss` (Issuer): 簽發者
    *   `sub` (Subject): 主題（通常是使用者的唯一標識符）
    *   `aud` (Audience): 接收者
    *   `exp` (Expiration Time): 過期時間（時間戳）
    *   `nbf` (Not Before): 生效時間（時間戳）
    *   `iat` (Issued At): 簽發時間（時間戳）
    *   `jti` (JWT ID): JWT 的唯一標識符

*   **公開聲明 (Public Claims):** 這些可以由使用 JWT 的人自由定義，但為了避免衝突，它們應該在 [IANA JSON Web Token Registry](https://www.iana.org/assignments/json-web-token/json-web-token.xhtml) 中定義，或包含一個抗衝突的命名空間。

*   **私有聲明 (Private Claims):** 這些是為在同意使用它們的各方之間共享資訊而創建的自訂聲明，既不是註冊聲明也不是公開聲明。

**重要提示：** 負載僅經過 **Base64Url** 編碼，並未加密。這意味著任何能夠截獲 JWT 的人都可以讀取其內容。因此，**切勿在負載中存放任何敏感資訊**，例如密碼。

**範例：**
```json
{
  "sub": "1234567890",
  "name": "John Doe",
  "iat": 1516239022,
  "admin": true
}
```
**編碼後：** `eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyLCJhZG1pbiI6dHJ1ZX0`

---

#### 3. 簽章 (Signature)

簽章是用於驗證訊息在傳輸過程中沒有被篡改，並且對於使用私鑰簽章的令牌，它還可以驗證 JWT 的發送者是誰。

簽章的產生方式如下：
1.  取編碼後的標頭 (Header)。
2.  取編碼後的負載 (Payload)。
3.  取一個**密鑰 (Secret)**。
4.  將前兩者用點 (`.`) 連接起來。
5.  使用標頭中指定的加密演算法 (`alg`)，搭配密鑰對上述字串進行雜湊計算。

**公式：**
```
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret
)
```

這個簽章確保了資料的完整性。只有持有密鑰的伺服器才能驗證令牌的有效性。如果有人試圖修改標頭或負載，由於他們沒有密鑰，無法產生出正確的簽章，因此伺服器在驗證時會發現簽章不匹配，並拒絕該令牌。

---

### JWT 與雜湊計算 (Hash Computing) 的關係及其運作方式

JWT 簽章的核心就是**雜湊計算 (Hash Computing)**，但它採用了一種更安全的形式，稱為 **HMAC (Hash-based Message Authentication Code)**。

*   **雜湊計算是什麼？**
    雜湊是一種單向加密演算法，它可以將任意長度的輸入資料轉換為一個固定長度的、獨一無二的字串（稱為「雜湊值」或「摘要」）。這種轉換是不可逆的，意味著無法從雜湊值反推出原始資料。任何對原始資料的微小改動，都會導致產生完全不同的雜湊值。

*   **JWT 如何運用雜湊計算？**
    JWT 不僅僅是簡單地對標頭和負載進行雜湊，因為那樣做並不安全。如果只做簡單雜湊，任何人都可以修改負載，然後重新計算雜湊值，從而偽造一個新的令牌。

    為了防止這種情況，JWT 使用了 **HMAC**。HMAC 在進行雜湊計算時，會額外引入一個**密鑰 (Secret)**。這個密鑰只有伺服器知道。

    **運作流程如下：**
    1.  伺服器將 **編碼後的標頭** 和 **編碼後的負載** 用點 (`.`) 連接起來，形成一個訊息字串。
    2.  伺服器使用指定的雜湊演算法（例如 `HS256`），將這個訊息字串和**密鑰**一起進行運算。
    3.  這個運算產生的結果就是最終的**簽章**。

    當伺服器收到一個 JWT 時，它會重複完全相同的過程：用它自己儲存的密鑰，對收到的標頭和負載重新計算一次簽章。然後，它會比較自己計算出的新簽章與 JWT 中附帶的原始簽章。

    *   如果兩者**完全一致**，伺服器就知道：
        1.  **資料完整性 (Integrity):** 令牌的內容（標頭和負載）在傳輸過程中沒有被任何人修改過。
        2.  **身份驗證 (Authentication):** 這個令牌確實是由持有相同密鑰的合法方簽發的。
    *   如果兩者**不一致**，則表示令牌是偽造的或已被篡改，伺服器會立即拒絕該請求。

---

### JWT 與 API Key 的比較

在保護 API 端點時，JWT 和 API Key 都是常見的驗證機制，但它們的設計理念和適用場景有所不同。

| 特性 | API Key | JSON Web Token (JWT) |
| :--- | :--- | :--- |
| **本質** | 一個簡單的、隨機生成的字串。 | 一個包含結構化資料 (JSON) 的加密簽章字串。 |
| **狀態管理** | **有狀態 (Stateful)**。伺服器需要一個資料庫來儲存每個 Key 對應的身份、權限和狀態。 | **無狀態 (Stateless)**。所有必要的資訊（如使用者 ID、權限、過期時間）都包含在令牌本身，伺服器只需驗證簽章即可。 |
| **設定複雜度** | **較簡單**。只需生成一個隨機字串並存入資料庫即可。 | **較複雜**。需要設定簽章演算法、管理密鑰，並處理令牌的簽發和驗證流程。 |
| **權限控制** | **較粗糙**。通常一個 API Key 對應一組固定的權限。若要實現細粒度的權限控制，需要在伺服器端進行複雜的查詢。 | **細粒度 (Granular)**。可以在 JWT 的負載 (Payload) 中直接定義詳細的權限、角色和存取範圍，實現非常靈活的權限管理。 |
| **安全性** | - **傳輸安全**：依賴於 HTTPS 來防止被竊聽。<br>- **撤銷**：可以立即在伺服器端將其禁用。<br>- **洩漏風險**：一旦洩漏，攻擊者可以永久使用，除非被手動撤銷。 | - **傳輸安全**：同樣依賴 HTTPS。<br>- **內容安全**：簽章機制可以防止資料在傳輸過程中被篡改。<br>- **撤銷**：標準 JWT 本身難以立即撤銷。一旦簽發，在過期前都有效。需要額外的機制（如黑名單）來實現。 |
| **適用場景** | - 授權**專案或應用程式**存取 API。<br>- 公開 API 或需要長期存取權限的機器對機器 (M2M) 通訊。<br>- 請求速率限制和用量追蹤。 | - **使用者身份驗證**和授權。<br>- 短期的、有時效性的存取權限。<br>- 單次登入 (SSO) 系統。<br>- 需要在不同服務之間安全傳遞使用者資訊的微服務架構。 |

---

#### 總結

*   **API Key** 更像是**一把永久的鑰匙**。它識別的是「哪個應用程式」在發送請求。它的設定簡單，適合用於授權信任的客戶端或追蹤 API 使用情況，但權限控制較為固定。

*   **JWT** 更像是**一張有時效的通行證或身份證**。它不僅識別「是誰」在發送請求，還詳細說明了「他能做什麼」以及「權限何時到期」。它的無狀態特性使其在分散式系統和微服務架構中極具擴展性，並且能提供非常精細的權限控制。

總的來說，沒有絕對的好壞之分，選擇哪種機制取決於您的具體需求。如果是要識別和授權使用者，特別是在需要精細權限控制的場景下，**JWT 通常是更現代、更靈活的選擇**。如果只是需要一個簡單的方式來保護公開 API 或追蹤應用程式的用量，**API Key 則更為直接方便**。
